"""
Нахождение правильной скобочной последовательности (ПСП)
1 Каждой закрывающей скобке соответствует открывающая скобка того же типа,
при этом между ними должна быть правильная скобочная последовательность.
2 Не остаётся открывающих скобок, которые не соответствуют ни одной из закрывающих.
Решение:
Проходим по входным данным и все открывающие скобки добавляем в стек.
Когда встречаем закрывающую, проверяем, что в стеке сверху лежит открывающая скобка того же типа.
Если да, то вынимаем её из стека. Если нет, то это не ПСП.
После прохода проверяем, что стек пустой. Если не пустой, то это не ПСП. Если пустой — ПСП.


Для каждого элемента в массиве найти ближайший элемент,
который левее его в массиве и меньше по значению.
Решение:
Идём по массиву слева направо.
Для первого элемента ответа нет, поэтому просто добавляем его в стек.
Далее, когда рассматриваем элемент a[i] , удаляем из стека элементы до тех пор,
пока на вершине лежит элемент, больший чем a[i].
Мы можем спокойно удалить эти элементы,
так как они не будут являться ответом ни для одного из элементов правее a[i],
так как a[i] меньше удалённых и находится правее.
Найдя первый элемент, меньший рассматриваемого,
оставляем его в стеке и записываем как ответ для индекса i. Кладем a[i] в стек.


Обратная польская нотация
Основное отличие этой нотации в том, что она префиксная, то есть оператор стоит после операндов.
Пример:  то же самое, что  в привычной нам нотации.
С помощью стека удобно считать выражение, записанное в такой нотации:
добавляем в стек все операнды, пока не встретим оператор.
Как только встретили, достаём из стека два последних операнда,
применяем к ним оператор и результат кладём в стек.


Реализуйте собственный калькулятор, который принимает выражение,
записанное в обратной польской нотации.
Требуется поддержать операции +, -, *.
Все числа во входной последовательности положительны и меньше 10.
"""


def calculate(s):
    stack = []
    for i in s:
        if i == ' ':
            continue
        if '0' <= i <= '9':
            stack.append(ord(i) - ord('0'))
        else:
            b = stack.pop()
            a = stack.pop()

            if i == '+':
                stack.append(a + b)
            elif i == '-':
                stack.append(a - b)
            elif i == '*':
                stack.append(a * b)
    return stack.pop()
